// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

contract PowerVoting {

    struct VoteResult {
        uint256 optionId;        // proposal option id, generated by frontend when create the proposal
        uint256 votes;          // votes
    }

    struct Proposal {
        string cid;                  // proposal cid
        uint248 expTime;             // proposal expiration timestamp, second
        bool isCounted;              // whether proposal is counted
        uint256[] optionIds;         // proposal options ids
        VoteResult[] voteResults;    // proposal vote result list
    }

    // proposal info, key is proposal cid
    mapping(string => Proposal) proposalsMap;

    // main net proposal cid list
    string[] mainProposalCids;
    // test net proposal cid list
    string[] testProposalCids;

    struct VoteInfo {
        uint8 optionId;         // proposal option id, generated by frontend when create the proposal
        uint248 votePercent;    // votePercent = 100 * real percent
    }

    // proposal page struct
    struct PageRes {
        uint256 totalSize;          // total proposal size
        Proposal[] proposalList;    // proposal list
    }

    // votor information for proposal, outside key is proposal cid, inside key is votor address, inside value is VoteInfo list
    mapping(string => mapping(address => VoteInfo[])) proposalVotesMap;

    // option votes for proposal, outside key is proposal cid, inside key is proposal option id, inside value is proposal option votes
    mapping(string => mapping(uint256 => uint256)) proposalOptionVotesMap;  

    // votor addresses, key is proposal cid, value is votors' address list
    mapping(string => address[]) proposalVotorsAddrs;


    address public onwer;
    constructor() {
        onwer = msg.sender;
    }

    /**
     * create a proposal and store it into mapping
     * 
     * @param proposalCid: proposal content is stored in ipfs, proposal cid is ipfs cid for proposal content
     * @param optionIds: proposal option ids
     * @param expTime: proposal expiration timestamp, second
     * @param net: net type, 1: main 2:test
     */
    function createProposal(string calldata proposalCid, uint256[] calldata optionIds, uint248 expTime, uint256 net) external {

        // requires option_ids.length > 0 && option_ids.length <= 5
        require(optionIds.length != 0 && optionIds.length <= 5, "1001");

        // create a proposal instance
        proposalsMap[proposalCid].optionIds = optionIds;
        proposalsMap[proposalCid].expTime = expTime;
        proposalsMap[proposalCid].cid = proposalCid;

        // save proposal cid to proposal cid list
        if (net == 1) {
            mainProposalCids.push(proposalCid);
        } else {
            testProposalCids.push(proposalCid);
        }

    }

    /**
     * get proposal page
     * @param pageIndex: page index
     * @param pageSize: page size
     * @param net: net type, 1: main 2:test
     */
    function proposalList(int256 pageIndex, int256 pageSize, uint256 net) external view returns (PageRes memory) {
        // require pageIndex > 0
        require(pageIndex > 0, "1012");
        int256 length = net == 1 ? int256(mainProposalCids.length) : int256(testProposalCids.length);
        // require pageIndex <= length / pageSize + 1
        require(pageIndex * pageSize <= length + pageSize, "1011");
        

        // set start and end
        int256 start;
        int256 end;
        if (pageSize > length) {
            start = length > 0 ? length - 1 : -1;
            end = -1;
        } else {
            start = length - (pageIndex - 1) * pageSize - 1;
            end = start >= pageSize ? start - pageSize : -1;
        }
        
        // get proposal list and total size
        PageRes memory res;
        res.totalSize = uint256(length);
        Proposal[] memory list = new Proposal[](uint256(start - end));
        uint256 index;
        // if main net, get proposal id from mainProposalCids, else from testProposalCids
        if (net == 1) {
            for(int256 i = start; i > end; --i){
                list[index++] = (proposalsMap[mainProposalCids[uint256(i)]]);
            }
        } else {
            for(int256 i = start; i > end; --i){
                list[index++] = (proposalsMap[testProposalCids[uint256(i)]]);
            }
        }
        
        res.proposalList = list;
        return res;
    }

    /**
     * get proposal list by proposal cid list
     * @param proposalCidList: proposal cid list
     */
    function getProposalList(string[] memory proposalCidList) external view returns (Proposal[] memory){
        uint256 len = proposalCidList.length;
        Proposal[] memory res = new Proposal[](len);
        for(uint256 i; i < len; ++i){
            res[i] = proposalsMap[proposalCidList[i]];
        }
        return res;
    }

    /**
     * get proposal by start and end index
     * @param start: start index
     * @param end: end index
     * @param net: network type, 1-main 2-test
     */
    function getProposalListByIndex(uint256 start, uint256 end, uint256 net) external view returns(Proposal[] memory) {
        uint256 len;
        string[] memory cidList;
        if(net == 1){
            len = mainProposalCids.length;
            cidList = mainProposalCids;
        } else {
            len = testProposalCids.length;
            cidList = testProposalCids;
        }
        // require cid length > start index
        require(len > start, "1013");
        if(end > len){
            end = len;
        }
        Proposal[] memory res = new Proposal[](end - start);
        uint256 index;
        for(uint256 i = start; i < end; ++i){
            res[index++] = proposalsMap[cidList[i]];
        }
        return res;
    }


    /**
     * getProposal
     * @param proposalCid:  proposal content is stored in ipfs, proposal cid is ipfs cid for proposal content
     */
    function getProposal(string calldata proposalCid) external view returns (Proposal memory) {
        return proposalsMap[proposalCid];
    }

    /**
     * vote on a proposal
     * 
     * @param proposalCid:  proposal content is stored in ipfs, proposal cid is ipfs cid for proposal content
     * @param voteInfoList: vote info list
     */
    function vote(string calldata proposalCid, VoteInfo[] calldata voteInfoList) external {

        // requires voteInfoList.length > 0 && voteInfoList.length <= 5
        require(voteInfoList.length != 0 && voteInfoList.length <= 5, "1002");
        // if proposal is expired, won't be allowd to vote
        require(proposalsMap[proposalCid].expTime > block.timestamp, "1003");
        // requires votors number < 10000
        require(proposalVotorsAddrs[proposalCid].length < 10000, "1004");
        // if votor has already voted on this proposal, won't be allowd to vote
        require(proposalVotesMap[proposalCid][msg.sender].length == 0, "1005");
        uint256 percent;
        uint256 len = voteInfoList.length;
        for (uint256 i; i < len; ++i) {
            // check percent
            percent += voteInfoList[i].votePercent;
            // save vote info
            proposalVotesMap[proposalCid][msg.sender].push(voteInfoList[i]);
        }
        // requires votes percents > 0 && votes percents <= 100 
        require(percent != 0 && percent <= 100, "1006");

        // update votes map
        // proposalVotesMap[proposalCid][msg.sender] = voteInfoList;
        // save votor address
        proposalVotorsAddrs[proposalCid].push(msg.sender);

    }

    /**
     * count a proposal
     * 
     * @param proposalCid : proposal content is stored in ipfs, proposal cid is ipfs cid for proposal content
     */
    function count(string calldata proposalCid) public {

        // requires proposal is not counted
        require(proposalsMap[proposalCid].isCounted == false, "1007");
        // requires proposal counting time reached
        require(proposalsMap[proposalCid].expTime < block.timestamp, "1008");
        // only the following address is allowd to call count function
        require(msg.sender == onwer, "1009");
        // proposal must exist 
        require(bytes(proposalsMap[proposalCid].cid).length != 0, "1010");

        //set counted
        proposalsMap[proposalCid].isCounted = true;

        // count
        uint256 addrLen = proposalVotorsAddrs[proposalCid].length;
        for (uint256 i; i < addrLen; ++i) {
            address addr = proposalVotorsAddrs[proposalCid][i];
            uint256 balance = addr.balance / 1e18; // wei to eth
            uint256 voteMapLen = proposalVotesMap[proposalCid][addr].length;
            for (uint256 j; j < voteMapLen; ++j) {
                VoteInfo memory voteInfo = proposalVotesMap[proposalCid][addr][j];
                proposalOptionVotesMap[proposalCid][voteInfo.optionId] += balance * voteInfo.votePercent;
            }
        }

        //set votes results
        uint256 optionsLen = proposalsMap[proposalCid].optionIds.length;
        for (uint256 i; i < optionsLen; ++i) {
            VoteResult memory voteResult;
            voteResult.optionId = proposalsMap[proposalCid].optionIds[i];
            voteResult.votes = proposalOptionVotesMap[proposalCid][voteResult.optionId];
            proposalsMap[proposalCid].voteResults.push(voteResult);
        }

    }

    function countBatch(string[] calldata proposals) external {
        // only the following address is allowd to call count function
        require(msg.sender == onwer, "1009");
        for(uint256 k; k < proposals.length; ++k){
            string calldata proposalCid = proposals[k];
            count(proposalCid);
        }
    }

}